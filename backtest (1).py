# -*- coding: utf-8 -*-
"""backtest

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15R5tmrQAXUW_fDAENz3SSGmWgB1WK61Q
"""



from google.colab import files
uploaded = files.upload()

df = pd.read_csv('l1_day.csv')

df = df.sort_values(['ts_event', 'publisher_id'])
df = df.drop_duplicates(subset=['ts_event', 'publisher_id'], keep='first')
df = df.sort_values('ts_event')
print(df.head())

def get_snapshots(df):
    snapshots = []
    for ts_event, group in df.groupby('ts_event'):
        venues = []
        for _, row in group.iterrows():
            venues.append({
                'venue': row['publisher_id'],
                'ask_px': float(row['ask_px_00']),
                'ask_sz': int(row['ask_sz_00']),
                'fee': 0.0,        # Set to 0.0 unless you have fee data
                'rebate': 0.0      # Set to 0.0 unless you have rebate data
            })
        snapshots.append({'ts_event': ts_event, 'venues': venues})
    return snapshots

snapshots = get_snapshots(df)
print("Number of snapshots:", len(snapshots))

def compute_cost(split, venues, order_size, lambda_over, lambda_under, theta_queue):
    executed = 0
    cash_spent = 0.0
    for i in range(len(venues)):
        exe = min(split[i], venues[i]['ask_sz'])
        cash_spent += exe * (venues[i]['ask_px'] + venues[i]['fee'])
        executed += exe
        maker_rebate = max(split[i] - exe, 0) * venues[i]['rebate']
        cash_spent -= maker_rebate

    underfill = max(order_size - executed, 0)
    overfill = max(executed - order_size, 0)
    risk_pen = theta_queue * (underfill + overfill)
    cost_pen = lambda_under * underfill + lambda_over * overfill
    return cash_spent + risk_pen + cost_pen

def allocate(order_size, venues, lambda_over, lambda_under, theta_queue):
    step = 100  # 100-share chunks
    N = len(venues)
    splits = [[]]
    for v in range(N):
        new_splits = []
        for alloc in splits:
            used = sum(alloc)
            max_v = int(min(order_size - used, venues[v]['ask_sz']))
            for q in range(0, max_v + 1, step):
                new_splits.append(alloc + [q])
        splits = new_splits

    best_cost = float('inf')
    best_split = None
    for alloc in splits:
        if sum(alloc) != order_size:
            continue
        cost = compute_cost(alloc, venues, order_size, lambda_over, lambda_under, theta_queue)
        if cost < best_cost:
            best_cost = cost
            best_split = alloc
    return best_split, best_cost

ORDER_SIZE = 5000

def run_allocator_strategy(snapshots, lambda_over, lambda_under, theta_queue):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    costs_over_time = []
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        alloc, _ = allocate(min(remaining, ORDER_SIZE), venues, lambda_over, lambda_under, theta_queue)
        for i, v in enumerate(venues):
            qty = min(alloc[i], v['ask_sz'], remaining)
            cash_spent += qty * v['ask_px']
            fills += qty
            remaining -= qty
            if remaining <= 0:
                break
        costs_over_time.append(cash_spent)
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price, costs_over_time

def best_ask_strategy(snapshots):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        best = min(venues, key=lambda v: v['ask_px'])
        qty = min(best['ask_sz'], remaining)
        cash_spent += qty * best['ask_px']
        fills += qty
        remaining -= qty
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

def twap_strategy(snapshots):
    n_buckets = 9
    bucket_size = ORDER_SIZE // n_buckets
    cash_spent = 0.0
    fills = 0
    idx = 0
    for b in range(n_buckets):
        remaining = bucket_size
        while remaining > 0 and idx < len(snapshots):
            venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
            if not venues:
                idx += 1
                continue
            best = min(venues, key=lambda v: v['ask_px'])
            qty = min(best['ask_sz'], remaining)
            cash_spent += qty * best['ask_px']
            fills += qty
            remaining -= qty
            idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

def vwap_strategy(snapshots):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        total_sz = sum(v['ask_sz'] for v in venues)
        for v in venues:
            if total_sz == 0:
                continue
            target = int(remaining * v['ask_sz'] / total_sz)
            qty = min(target, v['ask_sz'], remaining)
            cash_spent += qty * v['ask_px']
            fills += qty
            remaining -= qty
            if remaining <= 0:
                break
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

param_grid = [0.01, 0.1, 1.0]
best_result = None
best_cost = float('inf')
best_params = None
for lo, lu, tq in product(param_grid, repeat=3):
    cost, avg_price, _ = run_allocator_strategy(snapshots, lo, lu, tq)
    if cost < best_cost:
        best_cost = cost
        best_result = (cost, avg_price)
        best_params = (lo, lu, tq)

from itertools import product # Import the product function from itertools

param_grid = [0.01, 0.1, 1.0]
best_result = None
best_cost = float('inf')
best_params = None
for lo, lu, tq in product(param_grid, repeat=3): # Now 'product' is defined
    cost, avg_price, _ = run_allocator_strategy(snapshots, lo, lu, tq)
    if cost < best_cost:
        best_cost = cost
        best_result = (cost, avg_price)
        best_params = (lo, lu, tq)

import numpy as np
import pandas as pd
import json
from itertools import product
import matplotlib.pyplot as plt

def compute_cost(split, venues, order_size, lambda_over, lambda_under, theta_queue):
    executed = 0
    cash_spent = 0.0
    for i in range(len(venues)):
        exe = min(split[i], venues[i]['ask_sz'])
        cash_spent += exe * (venues[i]['ask_px'] + venues[i]['fee'])
        executed += exe
        maker_rebate = max(split[i] - exe, 0) * venues[i]['rebate']
        cash_spent -= maker_rebate

    underfill = max(order_size - executed, 0)
    overfill = max(executed - order_size, 0)
    risk_pen = theta_queue * (underfill + overfill)
    cost_pen = lambda_under * underfill + lambda_over * overfill
    return cash_spent + risk_pen + cost_pen

def allocate(order_size, venues, lambda_over, lambda_under, theta_queue):
    step = 100  # 100-share chunks
    N = len(venues)
    splits = [[]]
    for v in range(N):
        new_splits = []
        for alloc in splits:
            used = sum(alloc)
            max_v = int(min(order_size - used, venues[v]['ask_sz']))
            for q in range(0, max_v + 1, step):
                new_splits.append(alloc + [q])
        splits = new_splits

    best_cost = float('inf')
    best_split = None
    for alloc in splits:
        if sum(alloc) != order_size:
            continue
        cost = compute_cost(alloc, venues, order_size, lambda_over, lambda_under, theta_queue)
        if cost < best_cost:
            best_cost = cost
            best_split = alloc
    return best_split, best_cost

ORDER_SIZE = 5000

def run_allocator_strategy(snapshots, lambda_over, lambda_under, theta_queue):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    costs_over_time = []
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        alloc, _ = allocate(min(remaining, ORDER_SIZE), venues, lambda_over, lambda_under, theta_queue)
        for i, v in enumerate(venues):
            qty = min(alloc[i], v['ask_sz'], remaining)
            cash_spent += qty * v['ask_px']
            fills += qty
            remaining -= qty
            if remaining <= 0:
                break
        costs_over_time.append(cash_spent)
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price, costs_over_time

def best_ask_strategy(snapshots):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        best = min(venues, key=lambda v: v['ask_px'])
        qty = min(best['ask_sz'], remaining)
        cash_spent += qty * best['ask_px']
        fills += qty
        remaining -= qty
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

def twap_strategy(snapshots):
    n_buckets = 9
    bucket_size = ORDER_SIZE // n_buckets
    cash_spent = 0.0
    fills = 0
    idx = 0
    for b in range(n_buckets):
        remaining = bucket_size
        while remaining > 0 and idx < len(snapshots):
            venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
            if not venues:
                idx += 1
                continue
            best = min(venues, key=lambda v: v['ask_px'])
            qty = min(best['ask_sz'], remaining)
            cash_spent += qty * best['ask_px']
            fills += qty
            remaining -= qty
            idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

def vwap_strategy(snapshots):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        total_sz = sum(v['ask_sz'] for v in venues)
        for v in venues:
            if total_sz == 0:
                continue
            target = int(remaining * v['ask_sz'] / total_sz)
            qty = min(target, v['ask_sz'], remaining)
            cash_spent += qty * v['ask_px']
            fills += qty
            remaining -= qty
            if remaining <= 0:
                break
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

param_grid = [0.01, 0.1, 1.0]
best_result = None
best_cost = float('inf')
best_params = None
for lo, lu, tq in product(param_grid, repeat=3):
    cost, avg_price, _ = run_allocator_strategy(snapshots, lo, lu, tq)
    if cost < best_cost:
        best_cost = cost
        best_result = (cost, avg_price)
        best_params = (lo, lu, tq)

def allocate(order_size, venues, lambda_over, lambda_under, theta_queue):
    step = 100  # 100-share chunks
    N = len(venues)
    splits = [[]]
    for v in range(N):
        new_splits = []
        for alloc in splits:
            used = sum(alloc)
            max_v = int(min(order_size - used, venues[v]['ask_sz']))
            for q in range(0, max_v + 1, step):
                new_splits.append(alloc + [q])
        splits = new_splits

    best_cost = float('inf')
    best_split = None # best_split is initialized as None
    for alloc in splits:
        # The following condition might not be satisfied by any allocation
        # if sum(alloc) != order_size:
        #    continue
        # Instead, find the allocation closest to the order size:
        if abs(sum(alloc) - order_size) < abs(sum(best_split) - order_size) if best_split is not None else float('inf'):
            cost = compute_cost(alloc, venues, order_size, lambda_over, lambda_under, theta_queue)
            if cost < best_cost:
                best_cost = cost
                best_split = alloc

    # If no allocation is found, return a default split
    if best_split is None:
        # For example, try to fill as much as possible from the first venue:
        best_split = [min(order_size, venues[0]['ask_sz']) if venues else 0] + [0] * (N - 1)

    return best_split, best_cost

best_ask_cost, best_ask_avg = best_ask_strategy(snapshots)
twap_cost, twap_avg = twap_strategy(snapshots)
vwap_cost, vwap_avg = vwap_strategy(snapshots)

def bps(base, comp):
    return 10000 * (base - comp) / base if base else 0

results = {
    "parameters": {
        "lambda_over": best_params[0],
        "lambda_under": best_params[1],
        "theta_queue": best_params[2],
    },
    "optimized": {
        "cost": best_result[0],
        "avg_price": best_result[1],
    },
    "baselines": {
        "best_ask": {"cost": best_ask_cost, "avg_price": best_ask_avg},
        "twap": {"cost": twap_cost, "avg_price": twap_avg},
        "vwap": {"cost": vwap_cost, "avg_price": vwap_avg},
    },
    "savings_bps": {
        "vs_best_ask": bps(best_ask_avg, best_result[1]),
        "vs_twap": bps(twap_avg, best_result[1]),
        "vs_vwap": bps(vwap_avg, best_result[1]),
    }
}
print(json.dumps(results, indent=2))

_, _, costs_over_time = run_allocator_strategy(snapshots, *best_params)
plt.plot(costs_over_time)
plt.xlabel('Snapshot')
plt.ylabel('Cumulative Cost')
plt.title('Cumulative Cost Over Time')
plt.savefig('results.png')
plt.show()

total_liquidity = sum(v['ask_sz'] for snap in snapshots for v in snap['venues'])
print("Total available liquidity in all snapshots:", total_liquidity)

print("Running allocator for remaining:", remaining)
print("Venues:", venues)
alloc, _ = allocate(min(remaining, ORDER_SIZE), venues, lambda_over, lambda_under, theta_queue)
print("Allocator returned:", alloc)

ORDER_SIZE = 5000  # This is already defined in your code
remaining = ORDER_SIZE  # Initialize 'remaining' here
venues = []  # Initialize venues to an empty list (or with actual venue data if available)
lambda_over = best_params[0] # Assuming best_params are defined previously, e.g. during optimization
lambda_under = best_params[1]
theta_queue = best_params[2]

print("Running allocator for remaining:", remaining)
print("Venues:", venues)
alloc, _ = allocate(min(remaining, ORDER_SIZE), venues, lambda_over, lambda_under, theta_queue)
print("Allocator returned:", alloc)

alloc, _ = allocate(min(remaining, ORDER_SIZE), venues, lambda_over, lambda_under, theta_queue)

alloc, _ = allocate(remaining, venues, lambda_over, lambda_under, theta_queue)

venues = [v for v in snapshots[0]['venues'] if v['ask_sz'] > 0]
alloc, cost = allocate(5000, venues, 0.01, 0.01, 0.01)
print("Test alloc:", alloc, "cost:", cost)

total_liquidity = sum(v['ask_sz'] for snap in snapshots for v in snap['venues'])
print("Total available liquidity in all snapshots:", total_liquidity)

venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]

# Assuming you want to access the first snapshot (index 0):
idx = 0
venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]

print("First snapshot venues (raw):", snapshots[0]['venues'])
print("First snapshot venues with shares:", [v for v in snapshots[0]['venues'] if v['ask_sz'] > 0])

for i, snap in enumerate(snapshots):
    venues = [v for v in snap['venues'] if v['ask_sz'] > 0]
    if venues:
        print(f"First non-empty snapshot: {i}")
        print(venues)
        break



import numpy as np
import pandas as pd
import json
from itertools import product
import matplotlib.pyplot as plt

ORDER_SIZE = 5000

def load_data(filename):
    df = pd.read_csv(filename)
    # Clean and convert ask_sz_00 to int
    df['ask_sz_00'] = pd.to_numeric(df['ask_sz_00'], errors='coerce').fillna(0).astype(int)
    # Only first message per publisher_id per ts_event
    df = df.sort_values(['ts_event', 'publisher_id'])
    df = df.drop_duplicates(subset=['ts_event', 'publisher_id'], keep='first')
    df = df.sort_values('ts_event')
    return df

def get_snapshots(df):
    snapshots = []
    for ts_event, group in df.groupby('ts_event'):
        venues = []
        for _, row in group.iterrows():
            venues.append({
                'venue': row['publisher_id'],
                'ask_px': float(row['ask_px_00']),
                'ask_sz': int(row['ask_sz_00']),
                'fee': 0.0,
                'rebate': 0.0
            })
        snapshots.append({'ts_event': ts_event, 'venues': venues})
    return snapshots

# Allocator per pseudocode
def compute_cost(split, venues, order_size, lambda_over, lambda_under, theta_queue):
    executed = 0
    cash_spent = 0.0
    for i in range(len(venues)):
        exe = min(split[i], venues[i]['ask_sz'])
        cash_spent += exe * (venues[i]['ask_px'] + venues[i]['fee'])
        executed += exe
        maker_rebate = max(split[i] - exe, 0) * venues[i]['rebate']
        cash_spent -= maker_rebate

    underfill = max(order_size - executed, 0)
    overfill = max(executed - order_size, 0)
    risk_pen = theta_queue * (underfill + overfill)
    cost_pen = lambda_under * underfill + lambda_over * overfill
    return cash_spent + risk_pen + cost_pen

def allocate(order_size, venues, lambda_over, lambda_under, theta_queue):
    step = 100  # 100-share chunks for tractability
    N = len(venues)
    splits = [[]]
    for v in range(N):
        new_splits = []
        for alloc in splits:
            used = sum(alloc)
            max_v = int(min(order_size - used, venues[v]['ask_sz']))
            for q in range(0, max_v + 1, step):
                new_splits.append(alloc + [q])
        splits = new_splits

    best_cost = float('inf')
    best_split = None
    for alloc in splits:
        if sum(alloc) != order_size:
            continue
        cost = compute_cost(alloc, venues, order_size, lambda_over, lambda_under, theta_queue)
        if cost < best_cost:
            best_cost = cost
            best_split = alloc
    return best_split, best_cost

def run_allocator_strategy(snapshots, lambda_over, lambda_under, theta_queue):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    costs_over_time = []
    # Find first snapshot with liquidity
    while idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if venues:
            break
        idx += 1
    # Backtest loop
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        alloc, _ = allocate(min(remaining, ORDER_SIZE), venues, lambda_over, lambda_under, theta_queue)
        if alloc is None:
            idx += 1
            continue
        for i, v in enumerate(venues):
            qty = min(alloc[i], v['ask_sz'], remaining)
            cash_spent += qty * v['ask_px']
            fills += qty
            remaining -= qty
            if remaining <= 0:
                break
        costs_over_time.append(cash_spent)
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price, costs_over_time

def best_ask_strategy(snapshots):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    while idx < len(snapshots) and remaining > 0:
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        best = min(venues, key=lambda v: v['ask_px'])
        qty = min(best['ask_sz'], remaining)
        cash_spent += qty * best['ask_px']
        fills += qty
        remaining -= qty
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

def twap_strategy(snapshots):
    n_buckets = 9
    bucket_size = ORDER_SIZE // n_buckets
    cash_spent = 0.0
    fills = 0
    idx = 0
    for b in range(n_buckets):
        remaining = bucket_size
        while remaining > 0 and idx < len(snapshots):
            venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
            if not venues:
                idx += 1
                continue
            best = min(venues, key=lambda v: v['ask_px'])
            qty = min(best['ask_sz'], remaining)
            cash_spent += qty * best['ask_px']
            fills += qty
            remaining -= qty
            idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

def vwap_strategy(snapshots):
    remaining = ORDER_SIZE
    cash_spent = 0.0
    fills = 0
    idx = 0
    while remaining > 0 and idx < len(snapshots):
        venues = [v for v in snapshots[idx]['venues'] if v['ask_sz'] > 0]
        if not venues:
            idx += 1
            continue
        total_sz = sum(v['ask_sz'] for v in venues)
        for v in venues:
            if total_sz == 0:
                continue
            target = int(remaining * v['ask_sz'] / total_sz)
            qty = min(target, v['ask_sz'], remaining)
            cash_spent += qty * v['ask_px']
            fills += qty
            remaining -= qty
            if remaining <= 0:
                break
        idx += 1
    avg_price = cash_spent / fills if fills else 0.0
    return cash_spent, avg_price

def bps(base, comp):
    return 10000 * (base - comp) / base if base else 0

def main():
    df = load_data('l1_day.csv')
    snapshots = get_snapshots(df)

    param_grid = [0.01, 0.1, 1.0]
    best_result = None
    best_cost = float('inf')
    best_params = None
    for lo, lu, tq in product(param_grid, repeat=3):
        cost, avg_price, _ = run_allocator_strategy(snapshots, lo, lu, tq)
        if cost < best_cost and avg_price > 0:
            best_cost = cost
            best_result = (cost, avg_price)
            best_params = (lo, lu, tq)

    best_ask_cost, best_ask_avg = best_ask_strategy(snapshots)
    twap_cost, twap_avg = twap_strategy(snapshots)
    vwap_cost, vwap_avg = vwap_strategy(snapshots)

    results = {
        "parameters": {
            "lambda_over": best_params[0],
            "lambda_under": best_params[1],
            "theta_queue": best_params[2],
        },
        "optimized": {
            "cost": best_result[0],
            "avg_price": best_result[1],
        },
        "baselines": {
            "best_ask": {"cost": best_ask_cost, "avg_price": best_ask_avg},
            "twap": {"cost": twap_cost, "avg_price": twap_avg},
            "vwap": {"cost": vwap_cost, "avg_price": vwap_avg},
        },
        "savings_bps": {
            "vs_best_ask": bps(best_ask_avg, best_result[1]),
            "vs_twap": bps(twap_avg, best_result[1]),
            "vs_vwap": bps(vwap_avg, best_result[1]),
        }
    }
    print(json.dumps(results, indent=2))

    # Optional: Cumulative cost plot
    _, _, costs_over_time = run_allocator_strategy(snapshots, *best_params)
    plt.plot(costs_over_time)
    plt.xlabel('Snapshot')
    plt.ylabel('Cumulative Cost')
    plt.title('Cumulative Cost Over Time')
    plt.savefig('results.png')
    plt.close()

if __name__ == "__main__":
    main()

_, _, costs_over_time = run_allocator_strategy(snapshots, *best_params)
import matplotlib.pyplot as plt
plt.plot(costs_over_time)
plt.xlabel('Snapshot')
plt.ylabel('Cumulative Cost')
plt.title('Cumulative Cost Over Time')
plt.savefig('results.png')
plt.show()

costs_over_time.append(cash_spent)

_, _, costs_over_time = run_allocator_strategy(snapshots, *best_params) # This line should already be in the cell.

# Add the following:
cash_spent, _, _ = run_allocator_strategy(snapshots, *best_params) # Get cash_spent from the strategy function

costs_over_time.append(cash_spent) # Now cash_spent is defined

print(f"Snapshot {idx}, remaining: {remaining}, fills: {fills}, cash_spent: {cash_spent}")

cash_spent, _, _ = run_allocator_strategy(snapshots, *best_params) # Get cash_spent from the strategy function
_, _, costs_over_time = run_allocator_strategy(snapshots, *best_params)
remaining = ORDER_SIZE
fills = 0 #Initialize fills to 0

print(f"Snapshot {idx}, remaining: {remaining}, fills: {fills}, cash_spent: {cash_spent}")

# Run the strategy and collect costs
_, _, costs_over_time = run_allocator_strategy(snapshots, *best_params)
print("Length of costs_over_time:", len(costs_over_time))
print("costs_over_time:", costs_over_time)

if len(costs_over_time) > 1:
    plt.plot(costs_over_time)
    plt.xlabel('Snapshot')
    plt.ylabel('Cumulative Cost')
    plt.title('Cumulative Cost Over Time')
    plt.savefig('results.png')
    plt.show()
else:
    print("Not enough data to plot a line!")

from google.colab import files
files.download('results.png')

